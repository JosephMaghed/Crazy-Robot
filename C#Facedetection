using OpenCvSharp;
using System.Collections.Generic;
using UnityEngine;
using static System.Net.Mime.MediaTypeNames;

public class FaceGestureDetector : MonoBehaviour
{
    WebCamTexture webcam;
    CascadeClassifier faceCascade;

    float baselineY = -1f;
    float baselineX = -1f;
    bool calibrated = false;
    bool neutral = true;

    float calibrationTime = 5f;
    float calibrationTimer = 0f;
    List<Vector2> calibrationSamples = new List<Vector2>();

    // Thresholds (scaled by face size)
    public float jumpMultiplier = 0.1f;
    public float duckMultiplier = 1.5f;
    public float swipeMultiplier = 3.0f;

    void Start()
    {
        // Start webcam
        webcam = new WebCamTexture(320, 240);
        GetComponent<Renderer>().material.mainTexture = webcam;
        webcam.Play();

        // Load face cascade
        string facePath = System.IO.Path.Combine(UnityEngine.Application.streamingAssetsPath, "haarcascades/haarcascade_frontalface_default.xml");
        if (!System.IO.File.Exists(facePath))
            Debug.LogError("Face cascade file not found: " + facePath);

        faceCascade = new CascadeClassifier(facePath);
    }

    void Update()
    {
        Mat frame = OpenCvSharp.Unity.TextureToMat(webcam);
        Mat gray = new Mat();
        Cv2.CvtColor(frame, gray, ColorConversionCodes.BGR2GRAY);

        var faces = faceCascade.DetectMultiScale(gray, 1.1, 4);

        if (faces.Length > 0)
        {
            var face = faces[0];
            Vector2 faceCenter = new Vector2(face.X + face.Width / 2, face.Y + face.Height / 2);

            // --- Calibration phase ---
            if (!calibrated)
            {
                calibrationTimer += Time.deltaTime;
                calibrationSamples.Add(faceCenter);

                int countdown = Mathf.CeilToInt(calibrationTime - calibrationTimer);
                string text = (countdown > 0) ? "Calibrating... " + countdown : "Calibrated!";
                Cv2.PutText(frame, text, new OpenCvSharp.Point(20, 40),
                            HersheyFonts.HersheySimplex, 1, Scalar.Red, 2);

                if (calibrationTimer >= calibrationTime)
                {
                    float sumX = 0f, sumY = 0f;
                    foreach (var sample in calibrationSamples)
                    {
                        sumX += sample.x;
                        sumY += sample.y;
                    }
                    baselineX = sumX / calibrationSamples.Count;
                    baselineY = sumY / calibrationSamples.Count;
                    calibrated = true;
                    Debug.Log("Calibration complete. Baseline X: " + baselineX + " Y: " + baselineY);
                }
            }
            else
            {
                // --- Movement detection ---
                float deltaY = faceCenter.y - baselineY;
                float deltaX = faceCenter.x - baselineX;

                // Scale thresholds by face size
                float jumpThreshold = face.Height * jumpMultiplier;
                float duckThreshold = face.Height * duckMultiplier;
                float swipeThreshold = face.Width * swipeMultiplier;

                // Detect Jump
                if (deltaY < -jumpThreshold && neutral)
                {
                    UnityEngine.Debug.Log("Jump detected " + deltaY);
                    neutral = false;
                }
                // Detect Swipe
                else if (deltaX > swipeThreshold && neutral)
                {
                    UnityEngine.Debug.Log("Swipe Right detected");
                    neutral = false;
                }
                else if (deltaX < -swipeThreshold && neutral)
                {
                    UnityEngine.Debug.Log("Swipe Left detected");
                    neutral = false;
                }
                // Reset to neutral if back in baseline range
                else if (deltaY > -jumpThreshold && deltaY < duckThreshold && deltaX < swipeThreshold && deltaX > -swipeThreshold)
                {
                    neutral = true;
                }
            }

            // Draw face 
            Cv2.Rectangle(frame, face, Scalar.Green, 2);

            // Draw baseline
            if (calibrated)
            {
                Cv2.Line(frame,
                    new OpenCvSharp.Point(0, baselineY),
                    new OpenCvSharp.Point(frame.Width, baselineY),
                    Scalar.Yellow, 2);
                Cv2.Line(frame,
                    new OpenCvSharp.Point(baselineX, 0),
                    new OpenCvSharp.Point(baselineX, frame.Height),
                    Scalar.Yellow, 2);
            }
        }
        else if (calibrated)
        {
            // --- If face not detected after calibration -> Jump ---
            Debug.Log("Jump detected (face lost)");
        }

        // Show frame
        GetComponent<Renderer>().material.mainTexture = OpenCvSharp.Unity.MatToTexture(frame);
    }
}
